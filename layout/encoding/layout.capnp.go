// Code generated by capnpc-go. DO NOT EDIT.

package encoding

import (
	math "math"
	capnp "zombiezen.com/go/capnproto2"
	text "zombiezen.com/go/capnproto2/encoding/text"
	schemas "zombiezen.com/go/capnproto2/schemas"
)

type Point struct{ capnp.Struct }

// Point_TypeID is the unique identifier for the type Point.
const Point_TypeID = 0xc261973e3eab2ed2

func NewPoint(s *capnp.Segment) (Point, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Point{st}, err
}

func NewRootPoint(s *capnp.Segment) (Point, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Point{st}, err
}

func ReadRootPoint(msg *capnp.Message) (Point, error) {
	root, err := msg.RootPtr()
	return Point{root.Struct()}, err
}

func (s Point) String() string {
	str, _ := text.Marshal(0xc261973e3eab2ed2, s.Struct)
	return str
}

func (s Point) X() float64 {
	return math.Float64frombits(s.Struct.Uint64(0))
}

func (s Point) SetX(v float64) {
	s.Struct.SetUint64(0, math.Float64bits(v))
}

func (s Point) Y() float64 {
	return math.Float64frombits(s.Struct.Uint64(8))
}

func (s Point) SetY(v float64) {
	s.Struct.SetUint64(8, math.Float64bits(v))
}

// Point_List is a list of Point.
type Point_List struct{ capnp.List }

// NewPoint creates a new list of Point.
func NewPoint_List(s *capnp.Segment, sz int32) (Point_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return Point_List{l}, err
}

func (s Point_List) At(i int) Point { return Point{s.List.Struct(i)} }

func (s Point_List) Set(i int, v Point) error { return s.List.SetStruct(i, v.Struct) }

// Point_Promise is a wrapper for a Point promised by a client call.
type Point_Promise struct{ *capnp.Pipeline }

func (p Point_Promise) Struct() (Point, error) {
	s, err := p.Pipeline.Struct()
	return Point{s}, err
}

type Rect struct{ capnp.Struct }

// Rect_TypeID is the unique identifier for the type Rect.
const Rect_TypeID = 0xaec331439d64b2ed

func NewRect(s *capnp.Segment) (Rect, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Rect{st}, err
}

func NewRootRect(s *capnp.Segment) (Rect, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Rect{st}, err
}

func ReadRootRect(msg *capnp.Message) (Rect, error) {
	root, err := msg.RootPtr()
	return Rect{root.Struct()}, err
}

func (s Rect) String() string {
	str, _ := text.Marshal(0xaec331439d64b2ed, s.Struct)
	return str
}

func (s Rect) Min() (Point, error) {
	p, err := s.Struct.Ptr(0)
	return Point{Struct: p.Struct()}, err
}

func (s Rect) HasMin() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Rect) SetMin(v Point) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewMin sets the min field to a newly
// allocated Point struct, preferring placement in s's segment.
func (s Rect) NewMin() (Point, error) {
	ss, err := NewPoint(s.Struct.Segment())
	if err != nil {
		return Point{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Rect) Max() (Point, error) {
	p, err := s.Struct.Ptr(1)
	return Point{Struct: p.Struct()}, err
}

func (s Rect) HasMax() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Rect) SetMax(v Point) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewMax sets the max field to a newly
// allocated Point struct, preferring placement in s's segment.
func (s Rect) NewMax() (Point, error) {
	ss, err := NewPoint(s.Struct.Segment())
	if err != nil {
		return Point{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

// Rect_List is a list of Rect.
type Rect_List struct{ capnp.List }

// NewRect creates a new list of Rect.
func NewRect_List(s *capnp.Segment, sz int32) (Rect_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Rect_List{l}, err
}

func (s Rect_List) At(i int) Rect { return Rect{s.List.Struct(i)} }

func (s Rect_List) Set(i int, v Rect) error { return s.List.SetStruct(i, v.Struct) }

// Rect_Promise is a wrapper for a Rect promised by a client call.
type Rect_Promise struct{ *capnp.Pipeline }

func (p Rect_Promise) Struct() (Rect, error) {
	s, err := p.Pipeline.Struct()
	return Rect{s}, err
}

func (p Rect_Promise) Min() Point_Promise {
	return Point_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Rect_Promise) Max() Point_Promise {
	return Point_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

type Insets struct{ capnp.Struct }

// Insets_TypeID is the unique identifier for the type Insets.
const Insets_TypeID = 0xf16a85218b805121

func NewInsets(s *capnp.Segment) (Insets, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 32, PointerCount: 0})
	return Insets{st}, err
}

func NewRootInsets(s *capnp.Segment) (Insets, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 32, PointerCount: 0})
	return Insets{st}, err
}

func ReadRootInsets(msg *capnp.Message) (Insets, error) {
	root, err := msg.RootPtr()
	return Insets{root.Struct()}, err
}

func (s Insets) String() string {
	str, _ := text.Marshal(0xf16a85218b805121, s.Struct)
	return str
}

func (s Insets) Top() float64 {
	return math.Float64frombits(s.Struct.Uint64(0))
}

func (s Insets) SetTop(v float64) {
	s.Struct.SetUint64(0, math.Float64bits(v))
}

func (s Insets) Left() float64 {
	return math.Float64frombits(s.Struct.Uint64(8))
}

func (s Insets) SetLeft(v float64) {
	s.Struct.SetUint64(8, math.Float64bits(v))
}

func (s Insets) Bottom() float64 {
	return math.Float64frombits(s.Struct.Uint64(16))
}

func (s Insets) SetBottom(v float64) {
	s.Struct.SetUint64(16, math.Float64bits(v))
}

func (s Insets) Right() float64 {
	return math.Float64frombits(s.Struct.Uint64(24))
}

func (s Insets) SetRight(v float64) {
	s.Struct.SetUint64(24, math.Float64bits(v))
}

// Insets_List is a list of Insets.
type Insets_List struct{ capnp.List }

// NewInsets creates a new list of Insets.
func NewInsets_List(s *capnp.Segment, sz int32) (Insets_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 32, PointerCount: 0}, sz)
	return Insets_List{l}, err
}

func (s Insets_List) At(i int) Insets { return Insets{s.List.Struct(i)} }

func (s Insets_List) Set(i int, v Insets) error { return s.List.SetStruct(i, v.Struct) }

// Insets_Promise is a wrapper for a Insets promised by a client call.
type Insets_Promise struct{ *capnp.Pipeline }

func (p Insets_Promise) Struct() (Insets, error) {
	s, err := p.Pipeline.Struct()
	return Insets{s}, err
}

type Guide struct{ capnp.Struct }

// Guide_TypeID is the unique identifier for the type Guide.
const Guide_TypeID = 0xcb9dd8613df5cb2b

func NewGuide(s *capnp.Segment) (Guide, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Guide{st}, err
}

func NewRootGuide(s *capnp.Segment) (Guide, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Guide{st}, err
}

func ReadRootGuide(msg *capnp.Message) (Guide, error) {
	root, err := msg.RootPtr()
	return Guide{root.Struct()}, err
}

func (s Guide) String() string {
	str, _ := text.Marshal(0xcb9dd8613df5cb2b, s.Struct)
	return str
}

func (s Guide) Frame() (Rect, error) {
	p, err := s.Struct.Ptr(0)
	return Rect{Struct: p.Struct()}, err
}

func (s Guide) HasFrame() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Guide) SetFrame(v Rect) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewFrame sets the frame field to a newly
// allocated Rect struct, preferring placement in s's segment.
func (s Guide) NewFrame() (Rect, error) {
	ss, err := NewRect(s.Struct.Segment())
	if err != nil {
		return Rect{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Guide) Insets() (Insets, error) {
	p, err := s.Struct.Ptr(1)
	return Insets{Struct: p.Struct()}, err
}

func (s Guide) HasInsets() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Guide) SetInsets(v Insets) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewInsets sets the insets field to a newly
// allocated Insets struct, preferring placement in s's segment.
func (s Guide) NewInsets() (Insets, error) {
	ss, err := NewInsets(s.Struct.Segment())
	if err != nil {
		return Insets{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Guide) ZIndex() int64 {
	return int64(s.Struct.Uint64(0))
}

func (s Guide) SetZIndex(v int64) {
	s.Struct.SetUint64(0, uint64(v))
}

// Guide_List is a list of Guide.
type Guide_List struct{ capnp.List }

// NewGuide creates a new list of Guide.
func NewGuide_List(s *capnp.Segment, sz int32) (Guide_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return Guide_List{l}, err
}

func (s Guide_List) At(i int) Guide { return Guide{s.List.Struct(i)} }

func (s Guide_List) Set(i int, v Guide) error { return s.List.SetStruct(i, v.Struct) }

// Guide_Promise is a wrapper for a Guide promised by a client call.
type Guide_Promise struct{ *capnp.Pipeline }

func (p Guide_Promise) Struct() (Guide, error) {
	s, err := p.Pipeline.Struct()
	return Guide{s}, err
}

func (p Guide_Promise) Frame() Rect_Promise {
	return Rect_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Guide_Promise) Insets() Insets_Promise {
	return Insets_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

const schema_8d032c18f4c65862 = "x\xdal\x91?k\x14a\x10\xc6\xe7\x99\xb9u\x95x" +
	"\xb8\x9b=\xc1.F,\xfc\x97\x90\x88U\xc0$\xa0\xa2" +
	"\x07\x06n\xc4\xc2\xc2\xc2M\xee\x8d\xb7r\xbb{\xe4\xde" +
	"\xe0\xc5\xca\xc6Jll\x84@\x1a\xc1\"H\x14\xfd\x08" +
	"\x0aZ\xa4\xb3\xf2\x1bXY\x08Z\xaf\xbcg\xee6\xdc" +
	"\xd9\xcd;\xf3\xe3y\x9e\x99w\xee$\x96y\xde\xfb\xca" +
	"Dz\xda;R\xfc\xfc\xd8\xdc\xb96\xff\xf9\x1d\x85U" +
	"\x14\xab\xf7\xbe\xfc>uI^\x90\xc7>QT\xc7\xcb" +
	"H\xe1\xaa\x15<&\x14\xdff\xdf..\xbe\x8a?\x91" +
	"V\xc1%\\q\xc4.\xb6\xa3\x0f}v\xaf\xcf^\xdc" +
	"\xffs5\xfe\xbe\xb3\xef\xd81\xe1c\xbc\x1d\x85\xfd\xaa" +
	"\xca\xef\x09\xc5\xb4>}>\xfd\xec\xd1/\x07WF\x84" +
	"\xdf\xf0\xebh\xaf\xcf\xee\xf2\x0f\x9a)\xda\xf1V\xbei" +
	"g\xd7\x10w\xb2\xce\xc2\x1d\xb3\x06\xdb\x00\xf4\xa8T\x88" +
	"* \x0a\xcf\x9f!\xd2\xb3\x02\x9dc\x84@\x0d\xae9" +
	"\xe3\x9a\xe7\x04z\x85\xe1\xa7I\x86\xa0\xdc\x86\x80\x80\xe0" +
	"\xa7qo\xbc;b\xd7\xc8\x13\xc9F\xfd&\xff\xe77" +
	"Y\xfa\xa1\x87\x09bL\x10\xb05\xa8Fton&" +
	"\xd24N\xf7\xf8P\xf7\xc6e\"]\x16\xe8\xedC\xba" +
	"\xf5\x05\"\xbd.\xd0\x06\x03\\\x03\x13\x85+\xaewK" +
	"\xa0w\x19S\xeb\x1bqj\x10\x94\xff\xfao\x8f\xa5$" +
	"\xeb\x1a\xdbEP\xde\xfa`\xf0\xa4\x9e5M\x0f\x1e1" +
	"\xbc\xb1\\\xf5\xac\xeb\x1b\xdbu\xc1\x82a\xb0\xd8\xdd\xf2" +
	"\xbe@[\x87\x82\x99\x0bD\xfa@\xa0mF\xc8\x07\xc9" +
	"\x12\x97\xac)\xd0\x0e#\x14\xa9A\x88\xc2\xd4\xed\xd5\x12" +
	"\xa8e\xf86\xef\x0cNr\xa2m\xd6\xed\xe0\xb1\xb4\x9a" +
	"[\x9b\xa7\x83\xe7\xd4F\xf2\xb05\x1c\xfe\x0d\x00\x00\xff" +
	"\xffN\x1a\x94\x8c"

func init() {
	schemas.Register(schema_8d032c18f4c65862,
		0xaec331439d64b2ed,
		0xc261973e3eab2ed2,
		0xcb9dd8613df5cb2b,
		0xf16a85218b805121)
}
