// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: github.com/overcyn/mochi/pb/text.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "github.com/overcyn/mochi/pb/Text.pbobjc.h"
 #import "github.com/overcyn/mochi/pb/Layout.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - MochiPBTextRoot

@implementation MochiPBTextRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - MochiPBTextRoot_FileDescriptor

static GPBFileDescriptor *MochiPBTextRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"text"
                                                 objcPrefix:@"MochiPB"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum MochiPBTextAlignment

GPBEnumDescriptor *MochiPBTextAlignment_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "TextAlignmentLeft\000TextAlignmentRight\000Tex"
        "tAlignmentCenter\000TextAlignmentJustified\000";
    static const int32_t values[] = {
        MochiPBTextAlignment_TextAlignmentLeft,
        MochiPBTextAlignment_TextAlignmentRight,
        MochiPBTextAlignment_TextAlignmentCenter,
        MochiPBTextAlignment_TextAlignmentJustified,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MochiPBTextAlignment)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MochiPBTextAlignment_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MochiPBTextAlignment_IsValidValue(int32_t value__) {
  switch (value__) {
    case MochiPBTextAlignment_TextAlignmentLeft:
    case MochiPBTextAlignment_TextAlignmentRight:
    case MochiPBTextAlignment_TextAlignmentCenter:
    case MochiPBTextAlignment_TextAlignmentJustified:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MochiPBStrikethroughStyle

GPBEnumDescriptor *MochiPBStrikethroughStyle_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "StrikethroughStyleNone\000StrikethroughStyl"
        "eSingle\000StrikethroughStyleDouble\000Striket"
        "hroughStyleThick\000StrikethroughStyleDotte"
        "d\000StrikethroughStyleDashed\000";
    static const int32_t values[] = {
        MochiPBStrikethroughStyle_StrikethroughStyleNone,
        MochiPBStrikethroughStyle_StrikethroughStyleSingle,
        MochiPBStrikethroughStyle_StrikethroughStyleDouble,
        MochiPBStrikethroughStyle_StrikethroughStyleThick,
        MochiPBStrikethroughStyle_StrikethroughStyleDotted,
        MochiPBStrikethroughStyle_StrikethroughStyleDashed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MochiPBStrikethroughStyle)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MochiPBStrikethroughStyle_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MochiPBStrikethroughStyle_IsValidValue(int32_t value__) {
  switch (value__) {
    case MochiPBStrikethroughStyle_StrikethroughStyleNone:
    case MochiPBStrikethroughStyle_StrikethroughStyleSingle:
    case MochiPBStrikethroughStyle_StrikethroughStyleDouble:
    case MochiPBStrikethroughStyle_StrikethroughStyleThick:
    case MochiPBStrikethroughStyle_StrikethroughStyleDotted:
    case MochiPBStrikethroughStyle_StrikethroughStyleDashed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MochiPBUnderlineStyle

GPBEnumDescriptor *MochiPBUnderlineStyle_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "UndrelineStyleNone\000UndrelineStyleSingle\000"
        "UndrelineStyleDouble\000UndrelineStyleThick"
        "\000UndrelineStyleDotted\000UndrelineStyleDash"
        "ed\000";
    static const int32_t values[] = {
        MochiPBUnderlineStyle_UndrelineStyleNone,
        MochiPBUnderlineStyle_UndrelineStyleSingle,
        MochiPBUnderlineStyle_UndrelineStyleDouble,
        MochiPBUnderlineStyle_UndrelineStyleThick,
        MochiPBUnderlineStyle_UndrelineStyleDotted,
        MochiPBUnderlineStyle_UndrelineStyleDashed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MochiPBUnderlineStyle)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MochiPBUnderlineStyle_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MochiPBUnderlineStyle_IsValidValue(int32_t value__) {
  switch (value__) {
    case MochiPBUnderlineStyle_UndrelineStyleNone:
    case MochiPBUnderlineStyle_UndrelineStyleSingle:
    case MochiPBUnderlineStyle_UndrelineStyleDouble:
    case MochiPBUnderlineStyle_UndrelineStyleThick:
    case MochiPBUnderlineStyle_UndrelineStyleDotted:
    case MochiPBUnderlineStyle_UndrelineStyleDashed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MochiPBTextWrap

GPBEnumDescriptor *MochiPBTextWrap_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "TextWrapNone\000TextWrapWord\000TextWrapCharac"
        "ter\000";
    static const int32_t values[] = {
        MochiPBTextWrap_TextWrapNone,
        MochiPBTextWrap_TextWrapWord,
        MochiPBTextWrap_TextWrapCharacter,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MochiPBTextWrap)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MochiPBTextWrap_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MochiPBTextWrap_IsValidValue(int32_t value__) {
  switch (value__) {
    case MochiPBTextWrap_TextWrapNone:
    case MochiPBTextWrap_TextWrapWord:
    case MochiPBTextWrap_TextWrapCharacter:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MochiPBTruncation

GPBEnumDescriptor *MochiPBTruncation_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "TruncationNone\000TruncationStart\000Truncatio"
        "nMiddle\000TruncationEnd\000";
    static const int32_t values[] = {
        MochiPBTruncation_TruncationNone,
        MochiPBTruncation_TruncationStart,
        MochiPBTruncation_TruncationMiddle,
        MochiPBTruncation_TruncationEnd,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MochiPBTruncation)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MochiPBTruncation_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MochiPBTruncation_IsValidValue(int32_t value__) {
  switch (value__) {
    case MochiPBTruncation_TruncationNone:
    case MochiPBTruncation_TruncationStart:
    case MochiPBTruncation_TruncationMiddle:
    case MochiPBTruncation_TruncationEnd:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MochiPBSizeFunc

@implementation MochiPBSizeFunc

@dynamic hasText, text;
@dynamic hasMinSize, minSize;
@dynamic hasMaxSize, maxSize;

typedef struct MochiPBSizeFunc__storage_ {
  uint32_t _has_storage_[1];
  MochiPBText *text;
  MochiPBPoint *minSize;
  MochiPBPoint *maxSize;
} MochiPBSizeFunc__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.className = GPBStringifySymbol(MochiPBText),
        .number = MochiPBSizeFunc_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MochiPBSizeFunc__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "minSize",
        .dataTypeSpecific.className = GPBStringifySymbol(MochiPBPoint),
        .number = MochiPBSizeFunc_FieldNumber_MinSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MochiPBSizeFunc__storage_, minSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "maxSize",
        .dataTypeSpecific.className = GPBStringifySymbol(MochiPBPoint),
        .number = MochiPBSizeFunc_FieldNumber_MaxSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MochiPBSizeFunc__storage_, maxSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MochiPBSizeFunc class]
                                     rootClass:[MochiPBTextRoot class]
                                          file:MochiPBTextRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MochiPBSizeFunc__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\007\000\003\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MochiPBText

@implementation MochiPBText

@dynamic hasStyle, style;
@dynamic text;

typedef struct MochiPBText__storage_ {
  uint32_t _has_storage_[1];
  MochiPBTextStyle *style;
  NSString *text;
} MochiPBText__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "style",
        .dataTypeSpecific.className = GPBStringifySymbol(MochiPBTextStyle),
        .number = MochiPBText_FieldNumber_Style,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MochiPBText__storage_, style),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = MochiPBText_FieldNumber_Text,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MochiPBText__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MochiPBText class]
                                     rootClass:[MochiPBTextRoot class]
                                          file:MochiPBTextRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MochiPBText__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MochiPBFont

@implementation MochiPBFont

@dynamic family;
@dynamic face;
@dynamic size;

typedef struct MochiPBFont__storage_ {
  uint32_t _has_storage_[1];
  NSString *family;
  NSString *face;
  double size;
} MochiPBFont__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "family",
        .dataTypeSpecific.className = NULL,
        .number = MochiPBFont_FieldNumber_Family,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MochiPBFont__storage_, family),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "face",
        .dataTypeSpecific.className = NULL,
        .number = MochiPBFont_FieldNumber_Face,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MochiPBFont__storage_, face),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = MochiPBFont_FieldNumber_Size,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MochiPBFont__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MochiPBFont class]
                                     rootClass:[MochiPBTextRoot class]
                                          file:MochiPBTextRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MochiPBFont__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MochiPBColor

@implementation MochiPBColor

@dynamic red;
@dynamic blue;
@dynamic green;
@dynamic alpha;

typedef struct MochiPBColor__storage_ {
  uint32_t _has_storage_[1];
  uint32_t red;
  uint32_t blue;
  uint32_t green;
  uint32_t alpha;
} MochiPBColor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "red",
        .dataTypeSpecific.className = NULL,
        .number = MochiPBColor_FieldNumber_Red,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MochiPBColor__storage_, red),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "blue",
        .dataTypeSpecific.className = NULL,
        .number = MochiPBColor_FieldNumber_Blue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MochiPBColor__storage_, blue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "green",
        .dataTypeSpecific.className = NULL,
        .number = MochiPBColor_FieldNumber_Green,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MochiPBColor__storage_, green),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "alpha",
        .dataTypeSpecific.className = NULL,
        .number = MochiPBColor_FieldNumber_Alpha,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MochiPBColor__storage_, alpha),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MochiPBColor class]
                                     rootClass:[MochiPBTextRoot class]
                                          file:MochiPBTextRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MochiPBColor__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MochiPBTextStyle

@implementation MochiPBTextStyle

@dynamic textAlignment;
@dynamic strikethroughStyle;
@dynamic hasStrikethroughColor, strikethroughColor;
@dynamic underlineStyle;
@dynamic hasUnderlineColor, underlineColor;
@dynamic hasFont, font;
@dynamic hyphenation;
@dynamic lineHeightMultiple;
@dynamic maxLines;
@dynamic hasTextColor, textColor;
@dynamic wrap;
@dynamic truncation;
@dynamic truncationString;

typedef struct MochiPBTextStyle__storage_ {
  uint32_t _has_storage_[1];
  MochiPBTextAlignment textAlignment;
  MochiPBStrikethroughStyle strikethroughStyle;
  MochiPBUnderlineStyle underlineStyle;
  MochiPBTextWrap wrap;
  MochiPBTruncation truncation;
  MochiPBColor *strikethroughColor;
  MochiPBColor *underlineColor;
  MochiPBFont *font;
  MochiPBColor *textColor;
  NSString *truncationString;
  double hyphenation;
  double lineHeightMultiple;
  int64_t maxLines;
} MochiPBTextStyle__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "textAlignment",
        .dataTypeSpecific.enumDescFunc = MochiPBTextAlignment_EnumDescriptor,
        .number = MochiPBTextStyle_FieldNumber_TextAlignment,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MochiPBTextStyle__storage_, textAlignment),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "strikethroughStyle",
        .dataTypeSpecific.enumDescFunc = MochiPBStrikethroughStyle_EnumDescriptor,
        .number = MochiPBTextStyle_FieldNumber_StrikethroughStyle,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MochiPBTextStyle__storage_, strikethroughStyle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "strikethroughColor",
        .dataTypeSpecific.className = GPBStringifySymbol(MochiPBColor),
        .number = MochiPBTextStyle_FieldNumber_StrikethroughColor,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MochiPBTextStyle__storage_, strikethroughColor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "underlineStyle",
        .dataTypeSpecific.enumDescFunc = MochiPBUnderlineStyle_EnumDescriptor,
        .number = MochiPBTextStyle_FieldNumber_UnderlineStyle,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MochiPBTextStyle__storage_, underlineStyle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "underlineColor",
        .dataTypeSpecific.className = GPBStringifySymbol(MochiPBColor),
        .number = MochiPBTextStyle_FieldNumber_UnderlineColor,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MochiPBTextStyle__storage_, underlineColor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "font",
        .dataTypeSpecific.className = GPBStringifySymbol(MochiPBFont),
        .number = MochiPBTextStyle_FieldNumber_Font,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MochiPBTextStyle__storage_, font),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "hyphenation",
        .dataTypeSpecific.className = NULL,
        .number = MochiPBTextStyle_FieldNumber_Hyphenation,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(MochiPBTextStyle__storage_, hyphenation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "lineHeightMultiple",
        .dataTypeSpecific.className = NULL,
        .number = MochiPBTextStyle_FieldNumber_LineHeightMultiple,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(MochiPBTextStyle__storage_, lineHeightMultiple),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "maxLines",
        .dataTypeSpecific.className = NULL,
        .number = MochiPBTextStyle_FieldNumber_MaxLines,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(MochiPBTextStyle__storage_, maxLines),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "textColor",
        .dataTypeSpecific.className = GPBStringifySymbol(MochiPBColor),
        .number = MochiPBTextStyle_FieldNumber_TextColor,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(MochiPBTextStyle__storage_, textColor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "wrap",
        .dataTypeSpecific.enumDescFunc = MochiPBTextWrap_EnumDescriptor,
        .number = MochiPBTextStyle_FieldNumber_Wrap,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(MochiPBTextStyle__storage_, wrap),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "truncation",
        .dataTypeSpecific.enumDescFunc = MochiPBTruncation_EnumDescriptor,
        .number = MochiPBTextStyle_FieldNumber_Truncation,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(MochiPBTextStyle__storage_, truncation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "truncationString",
        .dataTypeSpecific.className = NULL,
        .number = MochiPBTextStyle_FieldNumber_TruncationString,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(MochiPBTextStyle__storage_, truncationString),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MochiPBTextStyle class]
                                     rootClass:[MochiPBTextRoot class]
                                          file:MochiPBTextRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MochiPBTextStyle__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\t\002\r\000\004\022\000\006\022\000\010\016\000\n\016\000\020\022\000\022\010\000\024\t\000\032\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MochiPBTextStyle_TextAlignment_RawValue(MochiPBTextStyle *message) {
  GPBDescriptor *descriptor = [MochiPBTextStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MochiPBTextStyle_FieldNumber_TextAlignment];
  return GPBGetMessageInt32Field(message, field);
}

void SetMochiPBTextStyle_TextAlignment_RawValue(MochiPBTextStyle *message, int32_t value) {
  GPBDescriptor *descriptor = [MochiPBTextStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MochiPBTextStyle_FieldNumber_TextAlignment];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t MochiPBTextStyle_StrikethroughStyle_RawValue(MochiPBTextStyle *message) {
  GPBDescriptor *descriptor = [MochiPBTextStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MochiPBTextStyle_FieldNumber_StrikethroughStyle];
  return GPBGetMessageInt32Field(message, field);
}

void SetMochiPBTextStyle_StrikethroughStyle_RawValue(MochiPBTextStyle *message, int32_t value) {
  GPBDescriptor *descriptor = [MochiPBTextStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MochiPBTextStyle_FieldNumber_StrikethroughStyle];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t MochiPBTextStyle_UnderlineStyle_RawValue(MochiPBTextStyle *message) {
  GPBDescriptor *descriptor = [MochiPBTextStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MochiPBTextStyle_FieldNumber_UnderlineStyle];
  return GPBGetMessageInt32Field(message, field);
}

void SetMochiPBTextStyle_UnderlineStyle_RawValue(MochiPBTextStyle *message, int32_t value) {
  GPBDescriptor *descriptor = [MochiPBTextStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MochiPBTextStyle_FieldNumber_UnderlineStyle];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t MochiPBTextStyle_Wrap_RawValue(MochiPBTextStyle *message) {
  GPBDescriptor *descriptor = [MochiPBTextStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MochiPBTextStyle_FieldNumber_Wrap];
  return GPBGetMessageInt32Field(message, field);
}

void SetMochiPBTextStyle_Wrap_RawValue(MochiPBTextStyle *message, int32_t value) {
  GPBDescriptor *descriptor = [MochiPBTextStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MochiPBTextStyle_FieldNumber_Wrap];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t MochiPBTextStyle_Truncation_RawValue(MochiPBTextStyle *message) {
  GPBDescriptor *descriptor = [MochiPBTextStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MochiPBTextStyle_FieldNumber_Truncation];
  return GPBGetMessageInt32Field(message, field);
}

void SetMochiPBTextStyle_Truncation_RawValue(MochiPBTextStyle *message, int32_t value) {
  GPBDescriptor *descriptor = [MochiPBTextStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MochiPBTextStyle_FieldNumber_Truncation];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
